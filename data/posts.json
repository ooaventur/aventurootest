        try:
            raw = http_get(url)
            doc = Document(raw)
            body_html = doc.summary(html_partial=True)
            if body_html and not first_img:
                m = re.search(r'<img[^>]+src=["\'](http[^"\']+)["\']', body_html, flags=re.I)
                if m:
                    first_img = m.group(1)
        except Exception as e:
            print("readability error:", e)
    # 3) Fallback total
    if not body_html:
        try:
            raw = http_get(url)
            txt = strip_text(raw)
            return f"<p>{txt}</p>", ""
        except Exception:
            return "", ""
    return body_html, first_img

def slugify(s: str) -> str:
    s = (s or "").lower()
    s = re.sub(r"[^a-z0-9]+", "-", s)
    return s.strip("-") or "post"


def slugify_taxonomy(value: str) -> str:
    value = (value or "").strip().lower()
    value = re.sub(r"[^a-z0-9]+", "-", value)
    return value.strip("-")


def slug_to_label(slug: str) -> str:
    slug = (slug or "").strip()
    if not slug:
        return ""
    slug = slug.replace("_", " ").replace("-", " ")
    slug = re.sub(r"\s+", " ", slug)
    return slug.strip().title()


def _normalize_label_from_slug(label: str, slug: str) -> str:
    slug_norm = slugify_taxonomy(slug)
    label = (label or "").strip()
    if not slug_norm:
        return label
    if not label or slugify_taxonomy(label) == slug_norm:
        return slug_to_label(slug_norm)
    return label


def _normalize_post_entry(entry):
    if not isinstance(entry, dict):
        return None

    normalized = dict(entry)

    category = (normalized.get("category") or "").strip()
    subcategory = (normalized.get("subcategory") or "").strip()
    category_slug = (normalized.get("category_slug") or "").strip().strip("/")

    if category and "/" in category:
        parts = [p.strip() for p in category.split("/") if p.strip()]
        if parts:
            if len(parts) > 1 and not subcategory:
                subcategory = parts[-1]
            category = parts[0]

    slug_segments = [seg for seg in category_slug.split("/") if seg] if category_slug else []

    cat_slug = slugify_taxonomy(category)
    sub_slug = slugify_taxonomy(subcategory)

    if slug_segments:
        cat_slug = slug_segments[0] or cat_slug
        if not category:
            category = slug_to_label(cat_slug)
        if len(slug_segments) > 1:
            derived_sub = slug_segments[-1]
            if not sub_slug:
                sub_slug = derived_sub
            if not subcategory:
                subcategory = slug_to_label(derived_sub)
    else:
        if not cat_slug and category:
            cat_slug = slugify_taxonomy(category)
        if not sub_slug and subcategory:
            sub_slug = slugify_taxonomy(subcategory)

    category = _normalize_label_from_slug(category, cat_slug)
    if sub_slug:
        subcategory = _normalize_label_from_slug(subcategory, sub_slug)
    else:
        subcategory = (subcategory or "").strip()

    slug_parts = []
    if cat_slug:
        slug_parts.append(cat_slug)
    if sub_slug:
        slug_parts.append(sub_slug)
    category_slug = "/".join(slug_parts)

    normalized["category"] = category
    normalized["subcategory"] = subcategory
    if category_slug:
        normalized["category_slug"] = category_slug
    else:
        normalized.pop("category_slug", None)

    return normalized


def _normalize_date_string(value: str) -> str:
    value = (value or "").strip()
    if not value:
        return ""
    value = re.sub(r"\s+", " ", value)

    dt = None
